{
  "version": 3,
  "sources": ["../../../../../node_modules/unist-util-remove/lib/index.js"],
  "sourcesContent": ["/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n *\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [cascade=true]\n *   Whether to drop parent nodes if they had children, but all their children\n *   were filtered out.\n */\n\nimport {convert} from 'unist-util-is'\n\n/** @type {Array<unknown>} */\nconst empty = []\n\n/**\n * Change the given `tree` by removing all nodes that pass `test`.\n *\n * The tree is walked in preorder (NLR), visiting the node itself, then its\n * head, etc.\n *\n * @param tree\n *   Tree to change.\n * @param options\n *   Configuration (optional).\n * @param test\n *   `unist-util-is` compatible test.\n * @returns\n *   The given `tree` without nodes that pass `test`.\n *\n *   `null` is returned if `tree` itself didn\u2019t pass the test or is cascaded\n *   away.\n */\n// To do: next major: don\u2019t return `tree`.\nexport const remove =\n  /**\n   * @type {(\n   *  (<Tree extends Node>(node: Tree, options: Options, test: Test) => Tree | null) &\n   *  (<Tree extends Node>(node: Tree, test: Test) => Tree | null)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Options | null | undefined} [options]\n     * @param {Test | null | undefined} [test]\n     * @returns {Node | null}\n     */\n    function (tree, options, test) {\n      const is = convert(test || options)\n      const cascade =\n        !options || options.cascade === undefined || options.cascade === null\n          ? true\n          : options.cascade\n\n      return preorder(tree)\n\n      /**\n       * Check and remove nodes recursively in preorder.\n       * For each composite node, modify its children array in-place.\n       *\n       * @param {Node} node\n       * @param {number | null | undefined} [index]\n       * @param {Parent | null | undefined} [parent]\n       * @returns {Node | null}\n       */\n      function preorder(node, index, parent) {\n        /** @type {Array<Node>} */\n        // @ts-expect-error looks like a parent.\n        const children = node.children || empty\n        let childIndex = -1\n        let position = 0\n\n        if (is(node, index, parent)) {\n          return null\n        }\n\n        if (children.length > 0) {\n          // Move all living children to the beginning of the children array.\n          while (++childIndex < children.length) {\n            // @ts-expect-error looks like a parent.\n            if (preorder(children[childIndex], childIndex, node)) {\n              children[position++] = children[childIndex]\n            }\n          }\n\n          // Cascade delete.\n          if (cascade && !position) {\n            return null\n          }\n\n          // Drop other nodes.\n          children.length = position\n        }\n\n        return node\n      }\n    }\n  )\n"],
  "mappings": ";;;;;;AAYA;AAGA,IAAM,QAAQ,CAAC;AAqBR,IAAM,SAcT,SAAU,MAAM,SAAS,MAAM;AAC7B,QAAM,KAAK,QAAQ,QAAQ,OAAO;AAClC,QAAM,UACJ,CAAC,WAAW,QAAQ,YAAY,UAAa,QAAQ,YAAY,OAC7D,OACA,QAAQ;AAEd,SAAO,SAAS,IAAI;AAWpB,WAAS,SAAS,MAAM,OAAO,QAAQ;AAGrC,UAAM,WAAW,KAAK,YAAY;AAClC,QAAI,aAAa;AACjB,QAAI,WAAW;AAEf,QAAI,GAAG,MAAM,OAAO,MAAM,GAAG;AAC3B,aAAO;AAAA,IACT;AAEA,QAAI,SAAS,SAAS,GAAG;AAEvB,aAAO,EAAE,aAAa,SAAS,QAAQ;AAErC,YAAI,SAAS,SAAS,aAAa,YAAY,IAAI,GAAG;AACpD,mBAAS,cAAc,SAAS;AAAA,QAClC;AAAA,MACF;AAGA,UAAI,WAAW,CAAC,UAAU;AACxB,eAAO;AAAA,MACT;AAGA,eAAS,SAAS;AAAA,IACpB;AAEA,WAAO;AAAA,EACT;AACF;",
  "names": []
}
