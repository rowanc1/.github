{
  "version": 3,
  "sources": ["../../../../../node_modules/zwitch/index.js", "../../../../../node_modules/unist-util-select/lib/attribute.js", "../../../../../node_modules/unist-util-select/lib/name.js", "../../../../../node_modules/nth-check/lib/esm/parse.ts", "../../../../../node_modules/boolbase/index.js", "../../../../../node_modules/nth-check/lib/esm/compile.ts", "../../../../../node_modules/nth-check/lib/esm/index.ts", "../../../../../node_modules/unist-util-select/lib/util.js", "../../../../../node_modules/unist-util-select/lib/pseudo.js", "../../../../../node_modules/unist-util-select/lib/test.js", "../../../../../node_modules/unist-util-select/lib/walk.js", "../../../../../node_modules/css-selector-parser/lib/utils.js", "../../../../../node_modules/css-selector-parser/lib/parser-context.js", "../../../../../node_modules/css-selector-parser/lib/render.js", "../../../../../node_modules/css-selector-parser/lib/index.js", "../../../../../node_modules/unist-util-select/lib/parse.js", "../../../../../node_modules/unist-util-select/index.js"],
  "sourcesContent": ["/**\n * @callback Handler\n *   Handle a value, with a certain ID field set to a certain value.\n *   The ID field is passed to `zwitch`, and it\u2019s value is this function\u2019s\n *   place on the `handlers` record.\n * @param {...any} parameters\n *   Arbitrary parameters passed to the zwitch.\n *   The first will be an object with a certain ID field set to a certain value.\n * @returns {any}\n *   Anything!\n */\n\n/**\n * @callback UnknownHandler\n *   Handle values that do have a certain ID field, but it\u2019s set to a value\n *   that is not listed in the `handlers` record.\n * @param {unknown} value\n *   An object with a certain ID field set to an unknown value.\n * @param {...any} rest\n *   Arbitrary parameters passed to the zwitch.\n * @returns {any}\n *   Anything!\n */\n\n/**\n * @callback InvalidHandler\n *   Handle values that do not have a certain ID field.\n * @param {unknown} value\n *   Any unknown value.\n * @param {...any} rest\n *   Arbitrary parameters passed to the zwitch.\n * @returns {void|null|undefined|never}\n *   This should crash or return nothing.\n */\n\n/**\n * @template {InvalidHandler} [Invalid=InvalidHandler]\n * @template {UnknownHandler} [Unknown=UnknownHandler]\n * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]\n * @typedef Options\n *   Configuration (required).\n * @property {Invalid} [invalid]\n *   Handler to use for invalid values.\n * @property {Unknown} [unknown]\n *   Handler to use for unknown values.\n * @property {Handlers} [handlers]\n *   Handlers to use.\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * Handle values based on a field.\n *\n * @template {InvalidHandler} [Invalid=InvalidHandler]\n * @template {UnknownHandler} [Unknown=UnknownHandler]\n * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]\n * @param {string} key\n *   Field to switch on.\n * @param {Options<Invalid, Unknown, Handlers>} [options]\n *   Configuration (required).\n * @returns {{unknown: Unknown, invalid: Invalid, handlers: Handlers, (...parameters: Parameters<Handlers[keyof Handlers]>): ReturnType<Handlers[keyof Handlers]>, (...parameters: Parameters<Unknown>): ReturnType<Unknown>}}\n */\nexport function zwitch(key, options) {\n  const settings = options || {}\n\n  /**\n   * Handle one value.\n   *\n   * Based on the bound `key`, a respective handler will be called.\n   * If `value` is not an object, or doesn\u2019t have a `key` property, the special\n   * \u201Cinvalid\u201D handler will be called.\n   * If `value` has an unknown `key`, the special \u201Cunknown\u201D handler will be\n   * called.\n   *\n   * All arguments, and the context object, are passed through to the handler,\n   * and it\u2019s result is returned.\n   *\n   * @this {unknown}\n   *   Any context object.\n   * @param {unknown} [value]\n   *   Any value.\n   * @param {...unknown} parameters\n   *   Arbitrary parameters passed to the zwitch.\n   * @property {Handler} invalid\n   *   Handle for values that do not have a certain ID field.\n   * @property {Handler} unknown\n   *   Handle values that do have a certain ID field, but it\u2019s set to a value\n   *   that is not listed in the `handlers` record.\n   * @property {Handlers} handlers\n   *   Record of handlers.\n   * @returns {unknown}\n   *   Anything.\n   */\n  function one(value, ...parameters) {\n    /** @type {Handler|undefined} */\n    let fn = one.invalid\n    const handlers = one.handlers\n\n    if (value && own.call(value, key)) {\n      // @ts-expect-error Indexable.\n      const id = String(value[key])\n      // @ts-expect-error Indexable.\n      fn = own.call(handlers, id) ? handlers[id] : one.unknown\n    }\n\n    if (fn) {\n      return fn.call(this, value, ...parameters)\n    }\n  }\n\n  one.handlers = settings.handlers || {}\n  one.invalid = settings.invalid\n  one.unknown = settings.unknown\n\n  // @ts-expect-error: matches!\n  return one\n}\n", "/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').RuleAttr} RuleAttr\n * @typedef {import('./types.js').Node} Node\n */\n\nimport {zwitch} from 'zwitch'\n\n/** @type {(query: RuleAttr, node: Node) => boolean} */\nconst handle = zwitch('operator', {\n  unknown: unknownOperator,\n  // @ts-expect-error: hush.\n  invalid: exists,\n  handlers: {\n    '=': exact,\n    '^=': begins,\n    '$=': ends,\n    '*=': containsString,\n    '~=': containsArray\n  }\n})\n\n/**\n * @param {Rule} query\n * @param {Node} node\n * @returns {boolean}\n */\nexport function attribute(query, node) {\n  let index = -1\n\n  while (++index < query.attrs.length) {\n    if (!handle(query.attrs[index], node)) return false\n  }\n\n  return true\n}\n\n/**\n * Check whether an attribute exists.\n *\n * `[attr]`\n *\n * @param {RuleAttr} query\n * @param {Node} node\n * @returns {boolean}\n */\nfunction exists(query, node) {\n  // @ts-expect-error: Looks like a record.\n  return node[query.name] !== null && node[query.name] !== undefined\n}\n\n/**\n * Check whether an attribute has an exact value.\n *\n * `[attr=value]`\n *\n * @param {RuleAttr} query\n * @param {Node} node\n * @returns {boolean}\n */\nfunction exact(query, node) {\n  // @ts-expect-error: Looks like a record.\n  return exists(query, node) && String(node[query.name]) === query.value\n}\n\n/**\n * Check whether an attribute, as a list, contains a value.\n *\n * When the attribute value is not a list, checks that the serialized value\n * is the queried one.\n *\n * `[attr~=value]`\n *\n * @param {RuleAttr} query\n * @param {Node} node\n * @returns {boolean}\n */\nfunction containsArray(query, node) {\n  /** @type {unknown} */\n  // @ts-expect-error: Looks like a record.\n  const value = node[query.name]\n\n  if (value === null || value === undefined) return false\n\n  // If this is an array, and the query is contained in it, return true.\n  // Coverage comment in place because TS turns `Array.isArray(unknown)`\n  // into `Array<any>` instead of `Array<unknown>`.\n  // type-coverage:ignore-next-line\n  if (Array.isArray(value) && value.includes(query.value)) {\n    return true\n  }\n\n  // For all other values, return whether this is an exact match.\n  return String(value) === query.value\n}\n\n/**\n * Check whether an attribute has a substring as its start.\n *\n * `[attr^=value]`\n *\n * @param {RuleAttr} query\n * @param {Node} node\n * @returns {boolean}\n */\nfunction begins(query, node) {\n  /** @type {unknown} */\n  // @ts-expect-error: Looks like a record.\n  const value = node[query.name]\n\n  return Boolean(\n    query.value &&\n      typeof value === 'string' &&\n      value.slice(0, query.value.length) === query.value\n  )\n}\n\n/**\n * Check whether an attribute has a substring as its end.\n *\n * `[attr$=value]`\n *\n * @param {RuleAttr} query\n * @param {Node} node\n * @returns {boolean}\n */\nfunction ends(query, node) {\n  /** @type {unknown} */\n  // @ts-expect-error: Looks like a record.\n  const value = node[query.name]\n\n  return Boolean(\n    query.value &&\n      typeof value === 'string' &&\n      value.slice(-query.value.length) === query.value\n  )\n}\n\n/**\n * Check whether an attribute contains a substring.\n *\n * `[attr*=value]`\n *\n * @param {RuleAttr} query\n * @param {Node} node\n * @returns {boolean}\n */\nfunction containsString(query, node) {\n  /** @type {unknown} */\n  // @ts-expect-error: Looks like a record.\n  const value = node[query.name]\n  return Boolean(\n    query.value && typeof value === 'string' && value.includes(query.value)\n  )\n}\n\n// Shouldn\u2019t be called, parser throws an error instead.\n/**\n * @param {unknown} query\n * @returns {never}\n */\n/* c8 ignore next 4 */\nfunction unknownOperator(query) {\n  // @ts-expect-error: `operator` guaranteed.\n  throw new Error('Unknown operator `' + query.operator + '`')\n}\n", "/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').Node} Node\n */\n\n/**\n * Check whether a node has a type.\n *\n * @param {Rule} query\n * @param {Node} node\n */\nexport function name(query, node) {\n  return query.tagName === '*' || query.tagName === node.type\n}\n", null, "module.exports = {\n\ttrueFunc: function trueFunc(){\n\t\treturn true;\n\t},\n\tfalseFunc: function falseFunc(){\n\t\treturn false;\n\t}\n};", null, null, "/**\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Parent} Parent\n */\n\n/**\n * @param {Node} node\n * @returns {node is Parent}\n */\nexport function parent(node) {\n  // @ts-expect-error: looks like a record.\n  return Array.isArray(node.children)\n}\n", "/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').RulePseudo} RulePseudo\n * @typedef {import('./types.js').RulePseudoSelector} RulePseudoSelector\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').Node} Node\n */\n\nimport fauxEsmNthCheck from 'nth-check'\nimport {zwitch} from 'zwitch'\nimport {parent} from './util.js'\nimport {queryToSelectors, walk} from './walk.js'\n\n/** @type {import('nth-check').default} */\n// @ts-expect-error\nconst nthCheck = fauxEsmNthCheck.default || fauxEsmNthCheck\n\n/** @type {(rule: Rule | RulePseudo, node: Node, index: number | undefined, parent: Parent | undefined, state: SelectState) => boolean} */\nconst handle = zwitch('name', {\n  unknown: unknownPseudo,\n  invalid: invalidPseudo,\n  handlers: {\n    any: matches,\n    blank: empty,\n    empty,\n    'first-child': firstChild,\n    'first-of-type': firstOfType,\n    has,\n    'last-child': lastChild,\n    'last-of-type': lastOfType,\n    matches,\n    not,\n    'nth-child': nthChild,\n    'nth-last-child': nthLastChild,\n    'nth-of-type': nthOfType,\n    'nth-last-of-type': nthLastOfType,\n    'only-child': onlyChild,\n    'only-of-type': onlyOfType,\n    root,\n    scope\n  }\n})\n\npseudo.needsIndex = [\n  'any',\n  'first-child',\n  'first-of-type',\n  'last-child',\n  'last-of-type',\n  'matches',\n  'not',\n  'nth-child',\n  'nth-last-child',\n  'nth-of-type',\n  'nth-last-of-type',\n  'only-child',\n  'only-of-type'\n]\n\n/**\n * Check whether an node matches pseudo selectors.\n *\n * @param {Rule} query\n * @param {Node} node\n * @param {number | undefined} index\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\nexport function pseudo(query, node, index, parent, state) {\n  const pseudos = query.pseudos\n  let offset = -1\n\n  while (++offset < pseudos.length) {\n    if (!handle(pseudos[offset], node, index, parent, state)) return false\n  }\n\n  return true\n}\n\n/**\n * Check whether a node matches an `:empty` pseudo.\n *\n * @param {RulePseudo} _1\n * @param {Node} node\n * @returns {boolean}\n */\nfunction empty(_1, node) {\n  return parent(node) ? node.children.length === 0 : !('value' in node)\n}\n\n/**\n * Check whether a node matches a `:first-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Node} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction firstChild(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.nodeIndex === 0 // Specifically `0`, not falsey.\n}\n\n/**\n * Check whether a node matches a `:first-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Node} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction firstOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.typeIndex === 0\n}\n\n/**\n * @param {RulePseudoSelector} query\n * @param {Node} node\n * @param {number | undefined} _1\n * @param {Parent | undefined} _2\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction has(query, node, _1, _2, state) {\n  const fragment = {type: 'root', children: parent(node) ? node.children : []}\n  /** @type {SelectState} */\n  const childState = {\n    ...state,\n    // Not found yet.\n    found: false,\n    // Do walk deep.\n    shallow: false,\n    // One result is enough.\n    one: true,\n    scopeNodes: [node],\n    results: [],\n    rootQuery: queryToSelectors(query.value)\n  }\n\n  walk(childState, fragment)\n\n  return childState.results.length > 0\n}\n\n/**\n * Check whether a node matches a `:last-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Node} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction lastChild(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return (\n    typeof state.nodeCount === 'number' &&\n    state.nodeIndex === state.nodeCount - 1\n  )\n}\n\n/**\n * Check whether a node matches a `:last-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Node} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction lastOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return (\n    typeof state.typeCount === 'number' &&\n    state.typeIndex === state.typeCount - 1\n  )\n}\n\n/**\n * Check whether a node `:matches` further selectors.\n *\n * @param {RulePseudoSelector} query\n * @param {Node} node\n * @param {number | undefined} _1\n * @param {Parent | undefined} _2\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction matches(query, node, _1, _2, state) {\n  /** @type {SelectState} */\n  const childState = {\n    ...state,\n    // Not found yet.\n    found: false,\n    // Do walk deep.\n    shallow: false,\n    // One result is enough.\n    one: true,\n    scopeNodes: [node],\n    results: [],\n    rootQuery: queryToSelectors(query.value)\n  }\n\n  walk(childState, node)\n\n  return childState.results[0] === node\n}\n\n/**\n * Check whether a node does `:not` match further selectors.\n *\n * @param {RulePseudoSelector} query\n * @param {Node} node\n * @param {number | undefined} index\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction not(query, node, index, parent, state) {\n  return !matches(query, node, index, parent, state)\n}\n\n/**\n * Check whether a node matches an `:nth-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Node} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction nthChild(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query)\n  assertDeep(state, query)\n  return typeof state.nodeIndex === 'number' && fn(state.nodeIndex)\n}\n\n/**\n * Check whether a node matches an `:nth-last-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Node} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction nthLastChild(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query)\n  assertDeep(state, query)\n  return (\n    typeof state.nodeCount === 'number' &&\n    typeof state.nodeIndex === 'number' &&\n    fn(state.nodeCount - state.nodeIndex - 1)\n  )\n}\n\n/**\n * Check whether a node matches a `:nth-last-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Node} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction nthLastOfType(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query)\n  assertDeep(state, query)\n  return (\n    typeof state.typeIndex === 'number' &&\n    typeof state.typeCount === 'number' &&\n    fn(state.typeCount - 1 - state.typeIndex)\n  )\n}\n\n/**\n * Check whether a node matches an `:nth-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Node} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction nthOfType(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query)\n  assertDeep(state, query)\n  return typeof state.typeIndex === 'number' && fn(state.typeIndex)\n}\n\n/**\n * Check whether a node matches an `:only-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Node} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction onlyChild(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.nodeCount === 1\n}\n\n/**\n * Check whether a node matches an `:only-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Node} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction onlyOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.typeCount === 1\n}\n\n/**\n * Check whether a node matches a `:root` pseudo.\n *\n * @param {RulePseudo} _1\n * @param {Node} node\n * @param {number | undefined} _2\n * @param {Parent | undefined} parent\n * @returns {boolean}\n */\nfunction root(_1, node, _2, parent) {\n  return node && !parent\n}\n\n/**\n * Check whether a node matches a `:scope` pseudo.\n *\n * @param {RulePseudo} _1\n * @param {Node} node\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction scope(_1, node, _2, _3, state) {\n  return node && state.scopeNodes.includes(node)\n}\n\n// Shouldn\u2019t be called, parser gives correct data.\n/* c8 ignore next 3 */\nfunction invalidPseudo() {\n  throw new Error('Invalid pseudo-selector')\n}\n\n/**\n * @param {unknown} query\n * @returns {never}\n */\nfunction unknownPseudo(query) {\n  // @ts-expect-error: indexable.\n  if (query.name) {\n    // @ts-expect-error: indexable.\n    throw new Error('Unknown pseudo-selector `' + query.name + '`')\n  }\n\n  throw new Error('Unexpected pseudo-element or empty pseudo-class')\n}\n\n/**\n * @param {SelectState} state\n * @param {RulePseudo} query\n */\nfunction assertDeep(state, query) {\n  if (state.shallow) {\n    throw new Error('Cannot use `:' + query.name + '` without parent')\n  }\n}\n\n/**\n * @param {RulePseudo} query\n * @returns {(value: number) => boolean}\n */\nfunction getCachedNthCheck(query) {\n  /** @type {(value: number) => boolean} */\n  // @ts-expect-error: cache.\n  let fn = query._cachedFn\n\n  if (!fn) {\n    // @ts-expect-error: always string.\n    fn = nthCheck(query.value)\n    // @ts-expect-error: cache.\n    query._cachedFn = fn\n  }\n\n  return fn\n}\n", "/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').SelectState} SelectState\n */\n\nimport {attribute} from './attribute.js'\nimport {name} from './name.js'\nimport {pseudo} from './pseudo.js'\n\n/**\n * @param {Rule} query\n * @param {Node} node\n * @param {number | undefined} index\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\nexport function test(query, node, index, parent, state) {\n  if (query.id) throw new Error('Invalid selector: id')\n  if (query.classNames) throw new Error('Invalid selector: class')\n\n  return Boolean(\n    node &&\n      (!query.tagName || name(query, node)) &&\n      (!query.attrs || attribute(query, node)) &&\n      (!query.pseudos || pseudo(query, node, index, parent, state))\n  )\n}\n", "/**\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').RuleSet} RuleSet\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').Selectors} Selectors\n *\n * @typedef Nest\n *   Rule sets by nesting.\n * @property {Array<RuleSet> | undefined} descendant\n *   `a b`\n * @property {Array<RuleSet> | undefined} directChild\n *   `a > b`\n * @property {Array<RuleSet> | undefined} adjacentSibling\n *   `a + b`\n * @property {Array<RuleSet> | undefined} generalSibling\n *   `a ~ b`\n *\n * @typedef Counts\n *   Info on nodes in a parent.\n * @property {number} count\n *   Number of nodes.\n * @property {Map<string, number>} types\n *   Number of nodes by type.\n */\n\nimport {test} from './test.js'\nimport {parent} from './util.js'\n\n/** @type {Array<never>} */\nconst empty = []\n\n/**\n * Turn a query into a uniform object.\n *\n * @param {Selectors | RuleSet | null} query\n * @returns {Selectors}\n */\nexport function queryToSelectors(query) {\n  if (query === null) {\n    return {type: 'selectors', selectors: []}\n  }\n\n  if (query.type === 'ruleSet') {\n    return {type: 'selectors', selectors: [query]}\n  }\n\n  return query\n}\n\n/**\n * Walk a tree.\n *\n * @param {SelectState} state\n * @param {Node | undefined} tree\n */\nexport function walk(state, tree) {\n  if (tree) {\n    one(state, [], tree, undefined, undefined)\n  }\n}\n\n/**\n * Check a node.\n *\n * @param {SelectState} state\n * @param {Array<RuleSet>} currentRules\n * @param {Node} node\n * @param {number | undefined} index\n * @param {Parent | undefined} parentNode\n * @returns {Nest}\n */\nfunction one(state, currentRules, node, index, parentNode) {\n  /** @type {Nest} */\n  let nestResult = {\n    directChild: undefined,\n    descendant: undefined,\n    adjacentSibling: undefined,\n    generalSibling: undefined\n  }\n\n  nestResult = applySelectors(\n    state,\n    // Try the root rules for this node too.\n    combine(currentRules, state.rootQuery.selectors),\n    node,\n    index,\n    parentNode\n  )\n\n  // If this is a parent, and we want to delve into them, and we haven\u2019t found\n  // our single result yet.\n  if (parent(node) && !state.shallow && !(state.one && state.found)) {\n    all(state, nestResult, node)\n  }\n\n  return nestResult\n}\n\n/**\n * Check a node.\n *\n * @param {SelectState} state\n * @param {Nest} nest\n * @param {Parent} node\n * @returns {void}\n */\nfunction all(state, nest, node) {\n  const fromParent = combine(nest.descendant, nest.directChild)\n  /** @type {Array<RuleSet> | undefined} */\n  let fromSibling\n  let index = -1\n  /**\n   * Total counts.\n   * @type {Counts}\n   */\n  const total = {count: 0, types: new Map()}\n  /**\n   * Counts of previous siblings.\n   * @type {Counts}\n   */\n  const before = {count: 0, types: new Map()}\n\n  while (++index < node.children.length) {\n    count(total, node.children[index])\n  }\n\n  index = -1\n\n  while (++index < node.children.length) {\n    const child = node.children[index]\n    // Uppercase to prevent prototype polution, injecting `constructor` or so.\n    const name = child.type.toUpperCase()\n    // Before counting further nodes:\n    state.nodeIndex = before.count\n    state.typeIndex = before.types.get(name) || 0\n    // After counting all nodes.\n    state.nodeCount = total.count\n    state.typeCount = total.types.get(name)\n\n    // Only apply if this is a parent.\n    const forSibling = combine(fromParent, fromSibling)\n    const nest = one(state, forSibling, node.children[index], index, node)\n    fromSibling = combine(nest.generalSibling, nest.adjacentSibling)\n\n    // We found one thing, and one is enough.\n    if (state.one && state.found) {\n      break\n    }\n\n    count(before, node.children[index])\n  }\n}\n\n/**\n * Apply selectors to a node.\n *\n * @param {SelectState} state\n *   Current state.\n * @param {Array<RuleSet>} rules\n *   Rules to apply.\n * @param {Node} node\n *   Node to apply rules to.\n * @param {number | undefined} index\n *   Index of node in parent.\n * @param {Parent | undefined} parent\n *   Parent of node.\n * @returns {Nest}\n *   Further rules.\n */\nfunction applySelectors(state, rules, node, index, parent) {\n  /** @type {Nest} */\n  const nestResult = {\n    directChild: undefined,\n    descendant: undefined,\n    adjacentSibling: undefined,\n    generalSibling: undefined\n  }\n  let selectorIndex = -1\n\n  while (++selectorIndex < rules.length) {\n    const ruleSet = rules[selectorIndex]\n\n    // We found one thing, and one is enough.\n    if (state.one && state.found) {\n      break\n    }\n\n    // When shallow, we don\u2019t allow nested rules.\n    // Idea: we could allow a stack of parents?\n    // Might get quite complex though.\n    if (state.shallow && ruleSet.rule.rule) {\n      throw new Error('Expected selector without nesting')\n    }\n\n    // If this rule matches:\n    if (test(ruleSet.rule, node, index, parent, state)) {\n      const nest = ruleSet.rule.rule\n\n      // Are there more?\n      if (nest) {\n        /** @type {RuleSet} */\n        const rule = {type: 'ruleSet', rule: nest}\n        /** @type {keyof Nest} */\n        const label =\n          nest.nestingOperator === '+'\n            ? 'adjacentSibling'\n            : nest.nestingOperator === '~'\n            ? 'generalSibling'\n            : nest.nestingOperator === '>'\n            ? 'directChild'\n            : 'descendant'\n        add(nestResult, label, rule)\n      } else {\n        // We have a match!\n        state.found = true\n\n        if (!state.results.includes(node)) {\n          state.results.push(node)\n        }\n      }\n    }\n\n    // Descendant.\n    if (ruleSet.rule.nestingOperator === null) {\n      add(nestResult, 'descendant', ruleSet)\n    }\n    // Adjacent.\n    else if (ruleSet.rule.nestingOperator === '~') {\n      add(nestResult, 'generalSibling', ruleSet)\n    }\n    // Drop top-level nesting (`undefined`), direct child (`>`), adjacent sibling (`+`).\n  }\n\n  return nestResult\n}\n\n/**\n * Combine two lists, if needed.\n *\n * This is optimized to create as few lists as possible.\n *\n * @param {Array<RuleSet> | undefined} left\n * @param {Array<RuleSet> | undefined} right\n * @returns {Array<RuleSet>}\n */\nfunction combine(left, right) {\n  return left && right && left.length > 0 && right.length > 0\n    ? [...left, ...right]\n    : left && left.length > 0\n    ? left\n    : right && right.length > 0\n    ? right\n    : empty\n}\n\n/**\n * Add a rule to a nesting map.\n *\n * @param {Nest} nest\n * @param {keyof Nest} field\n * @param {RuleSet} rule\n */\nfunction add(nest, field, rule) {\n  const list = nest[field]\n  if (list) {\n    list.push(rule)\n  } else {\n    nest[field] = [rule]\n  }\n}\n\n/**\n * Count a node.\n *\n * @param {Counts} counts\n *   Counts.\n * @param {Node} node\n *   Node.\n * @returns {void}\n *   Nothing.\n */\nfunction count(counts, node) {\n  // Uppercase to prevent prototype polution, injecting `constructor` or so.\n  // Normalize because HTML is insensitive.\n  const name = node.type.toUpperCase()\n  const count = (counts.types.get(name) || 0) + 1\n  counts.count++\n  counts.types.set(name, count)\n}\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isIdentStart(c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c === '-') || (c === '_');\n}\nexports.isIdentStart = isIdentStart;\nfunction isIdent(c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c === '-' || c === '_';\n}\nexports.isIdent = isIdent;\nfunction isHex(c) {\n    return (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F') || (c >= '0' && c <= '9');\n}\nexports.isHex = isHex;\nfunction escapeIdentifier(s) {\n    var len = s.length;\n    var result = '';\n    var i = 0;\n    while (i < len) {\n        var chr = s.charAt(i);\n        if (exports.identSpecialChars[chr]) {\n            result += '\\\\' + chr;\n        }\n        else {\n            if (!(chr === '_' || chr === '-' ||\n                (chr >= 'A' && chr <= 'Z') ||\n                (chr >= 'a' && chr <= 'z') ||\n                (i !== 0 && chr >= '0' && chr <= '9'))) {\n                var charCode = chr.charCodeAt(0);\n                if ((charCode & 0xF800) === 0xD800) {\n                    var extraCharCode = s.charCodeAt(i++);\n                    if ((charCode & 0xFC00) !== 0xD800 || (extraCharCode & 0xFC00) !== 0xDC00) {\n                        throw Error('UCS-2(decode): illegal sequence');\n                    }\n                    charCode = ((charCode & 0x3FF) << 10) + (extraCharCode & 0x3FF) + 0x10000;\n                }\n                result += '\\\\' + charCode.toString(16) + ' ';\n            }\n            else {\n                result += chr;\n            }\n        }\n        i++;\n    }\n    return result;\n}\nexports.escapeIdentifier = escapeIdentifier;\nfunction escapeStr(s) {\n    var len = s.length;\n    var result = '';\n    var i = 0;\n    var replacement;\n    while (i < len) {\n        var chr = s.charAt(i);\n        if (chr === '\"') {\n            chr = '\\\\\"';\n        }\n        else if (chr === '\\\\') {\n            chr = '\\\\\\\\';\n        }\n        else if ((replacement = exports.strReplacementsRev[chr]) !== undefined) {\n            chr = replacement;\n        }\n        result += chr;\n        i++;\n    }\n    return \"\\\"\" + result + \"\\\"\";\n}\nexports.escapeStr = escapeStr;\nexports.identSpecialChars = {\n    '!': true,\n    '\"': true,\n    '#': true,\n    '$': true,\n    '%': true,\n    '&': true,\n    '\\'': true,\n    '(': true,\n    ')': true,\n    '*': true,\n    '+': true,\n    ',': true,\n    '.': true,\n    '/': true,\n    ';': true,\n    '<': true,\n    '=': true,\n    '>': true,\n    '?': true,\n    '@': true,\n    '[': true,\n    '\\\\': true,\n    ']': true,\n    '^': true,\n    '`': true,\n    '{': true,\n    '|': true,\n    '}': true,\n    '~': true\n};\nexports.strReplacementsRev = {\n    '\\n': '\\\\n',\n    '\\r': '\\\\r',\n    '\\t': '\\\\t',\n    '\\f': '\\\\f',\n    '\\v': '\\\\v'\n};\nexports.singleQuoteEscapeChars = {\n    n: '\\n',\n    r: '\\r',\n    t: '\\t',\n    f: '\\f',\n    '\\\\': '\\\\',\n    '\\'': '\\''\n};\nexports.doubleQuotesEscapeChars = {\n    n: '\\n',\n    r: '\\r',\n    t: '\\t',\n    f: '\\f',\n    '\\\\': '\\\\',\n    '\"': '\"'\n};\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = require(\"./utils\");\nfunction parseCssSelector(str, pos, pseudos, attrEqualityMods, ruleNestingOperators, substitutesEnabled) {\n    var l = str.length;\n    var chr = '';\n    function getStr(quote, escapeTable) {\n        var result = '';\n        pos++;\n        chr = str.charAt(pos);\n        while (pos < l) {\n            if (chr === quote) {\n                pos++;\n                return result;\n            }\n            else if (chr === '\\\\') {\n                pos++;\n                chr = str.charAt(pos);\n                var esc = void 0;\n                if (chr === quote) {\n                    result += quote;\n                }\n                else if ((esc = escapeTable[chr]) !== undefined) {\n                    result += esc;\n                }\n                else if (utils_1.isHex(chr)) {\n                    var hex = chr;\n                    pos++;\n                    chr = str.charAt(pos);\n                    while (utils_1.isHex(chr)) {\n                        hex += chr;\n                        pos++;\n                        chr = str.charAt(pos);\n                    }\n                    if (chr === ' ') {\n                        pos++;\n                        chr = str.charAt(pos);\n                    }\n                    result += String.fromCharCode(parseInt(hex, 16));\n                    continue;\n                }\n                else {\n                    result += chr;\n                }\n            }\n            else {\n                result += chr;\n            }\n            pos++;\n            chr = str.charAt(pos);\n        }\n        return result;\n    }\n    function getIdent() {\n        var result = '';\n        chr = str.charAt(pos);\n        while (pos < l) {\n            if (utils_1.isIdent(chr)) {\n                result += chr;\n            }\n            else if (chr === '\\\\') {\n                pos++;\n                if (pos >= l) {\n                    throw Error('Expected symbol but end of file reached.');\n                }\n                chr = str.charAt(pos);\n                if (utils_1.identSpecialChars[chr]) {\n                    result += chr;\n                }\n                else if (utils_1.isHex(chr)) {\n                    var hex = chr;\n                    pos++;\n                    chr = str.charAt(pos);\n                    while (utils_1.isHex(chr)) {\n                        hex += chr;\n                        pos++;\n                        chr = str.charAt(pos);\n                    }\n                    if (chr === ' ') {\n                        pos++;\n                        chr = str.charAt(pos);\n                    }\n                    result += String.fromCharCode(parseInt(hex, 16));\n                    continue;\n                }\n                else {\n                    result += chr;\n                }\n            }\n            else {\n                return result;\n            }\n            pos++;\n            chr = str.charAt(pos);\n        }\n        return result;\n    }\n    function skipWhitespace() {\n        chr = str.charAt(pos);\n        var result = false;\n        while (chr === ' ' || chr === \"\\t\" || chr === \"\\n\" || chr === \"\\r\" || chr === \"\\f\") {\n            result = true;\n            pos++;\n            chr = str.charAt(pos);\n        }\n        return result;\n    }\n    function parse() {\n        var res = parseSelector();\n        if (pos < l) {\n            throw Error('Rule expected but \"' + str.charAt(pos) + '\" found.');\n        }\n        return res;\n    }\n    function parseSelector() {\n        var selector = parseSingleSelector();\n        if (!selector) {\n            return null;\n        }\n        var res = selector;\n        chr = str.charAt(pos);\n        while (chr === ',') {\n            pos++;\n            skipWhitespace();\n            if (res.type !== 'selectors') {\n                res = {\n                    type: 'selectors',\n                    selectors: [selector]\n                };\n            }\n            selector = parseSingleSelector();\n            if (!selector) {\n                throw Error('Rule expected after \",\".');\n            }\n            res.selectors.push(selector);\n        }\n        return res;\n    }\n    function parseSingleSelector() {\n        skipWhitespace();\n        var selector = {\n            type: 'ruleSet'\n        };\n        var rule = parseRule();\n        if (!rule) {\n            return null;\n        }\n        var currentRule = selector;\n        while (rule) {\n            rule.type = 'rule';\n            currentRule.rule = rule;\n            currentRule = rule;\n            skipWhitespace();\n            chr = str.charAt(pos);\n            if (pos >= l || chr === ',' || chr === ')') {\n                break;\n            }\n            if (ruleNestingOperators[chr]) {\n                var op = chr;\n                pos++;\n                skipWhitespace();\n                rule = parseRule();\n                if (!rule) {\n                    throw Error('Rule expected after \"' + op + '\".');\n                }\n                rule.nestingOperator = op;\n            }\n            else {\n                rule = parseRule();\n                if (rule) {\n                    rule.nestingOperator = null;\n                }\n            }\n        }\n        return selector;\n    }\n    // @ts-ignore no-overlap\n    function parseRule() {\n        var rule = null;\n        while (pos < l) {\n            chr = str.charAt(pos);\n            if (chr === '*') {\n                pos++;\n                (rule = rule || {}).tagName = '*';\n            }\n            else if (utils_1.isIdentStart(chr) || chr === '\\\\') {\n                (rule = rule || {}).tagName = getIdent();\n            }\n            else if (chr === '.') {\n                pos++;\n                rule = rule || {};\n                (rule.classNames = rule.classNames || []).push(getIdent());\n            }\n            else if (chr === '#') {\n                pos++;\n                (rule = rule || {}).id = getIdent();\n            }\n            else if (chr === '[') {\n                pos++;\n                skipWhitespace();\n                var attr = {\n                    name: getIdent()\n                };\n                skipWhitespace();\n                // @ts-ignore\n                if (chr === ']') {\n                    pos++;\n                }\n                else {\n                    var operator = '';\n                    if (attrEqualityMods[chr]) {\n                        operator = chr;\n                        pos++;\n                        chr = str.charAt(pos);\n                    }\n                    if (pos >= l) {\n                        throw Error('Expected \"=\" but end of file reached.');\n                    }\n                    if (chr !== '=') {\n                        throw Error('Expected \"=\" but \"' + chr + '\" found.');\n                    }\n                    attr.operator = operator + '=';\n                    pos++;\n                    skipWhitespace();\n                    var attrValue = '';\n                    attr.valueType = 'string';\n                    // @ts-ignore\n                    if (chr === '\"') {\n                        attrValue = getStr('\"', utils_1.doubleQuotesEscapeChars);\n                        // @ts-ignore\n                    }\n                    else if (chr === '\\'') {\n                        attrValue = getStr('\\'', utils_1.singleQuoteEscapeChars);\n                        // @ts-ignore\n                    }\n                    else if (substitutesEnabled && chr === '$') {\n                        pos++;\n                        attrValue = getIdent();\n                        attr.valueType = 'substitute';\n                    }\n                    else {\n                        while (pos < l) {\n                            if (chr === ']') {\n                                break;\n                            }\n                            attrValue += chr;\n                            pos++;\n                            chr = str.charAt(pos);\n                        }\n                        attrValue = attrValue.trim();\n                    }\n                    skipWhitespace();\n                    if (pos >= l) {\n                        throw Error('Expected \"]\" but end of file reached.');\n                    }\n                    if (chr !== ']') {\n                        throw Error('Expected \"]\" but \"' + chr + '\" found.');\n                    }\n                    pos++;\n                    attr.value = attrValue;\n                }\n                rule = rule || {};\n                (rule.attrs = rule.attrs || []).push(attr);\n            }\n            else if (chr === ':') {\n                pos++;\n                var pseudoName = getIdent();\n                var pseudo = {\n                    name: pseudoName\n                };\n                // @ts-ignore\n                if (chr === '(') {\n                    pos++;\n                    var value = '';\n                    skipWhitespace();\n                    if (pseudos[pseudoName] === 'selector') {\n                        pseudo.valueType = 'selector';\n                        value = parseSelector();\n                    }\n                    else {\n                        pseudo.valueType = pseudos[pseudoName] || 'string';\n                        // @ts-ignore\n                        if (chr === '\"') {\n                            value = getStr('\"', utils_1.doubleQuotesEscapeChars);\n                            // @ts-ignore\n                        }\n                        else if (chr === '\\'') {\n                            value = getStr('\\'', utils_1.singleQuoteEscapeChars);\n                            // @ts-ignore\n                        }\n                        else if (substitutesEnabled && chr === '$') {\n                            pos++;\n                            value = getIdent();\n                            pseudo.valueType = 'substitute';\n                        }\n                        else {\n                            while (pos < l) {\n                                if (chr === ')') {\n                                    break;\n                                }\n                                value += chr;\n                                pos++;\n                                chr = str.charAt(pos);\n                            }\n                            value = value.trim();\n                        }\n                        skipWhitespace();\n                    }\n                    if (pos >= l) {\n                        throw Error('Expected \")\" but end of file reached.');\n                    }\n                    if (chr !== ')') {\n                        throw Error('Expected \")\" but \"' + chr + '\" found.');\n                    }\n                    pos++;\n                    pseudo.value = value;\n                }\n                rule = rule || {};\n                (rule.pseudos = rule.pseudos || []).push(pseudo);\n            }\n            else {\n                break;\n            }\n        }\n        return rule;\n    }\n    return parse();\n}\nexports.parseCssSelector = parseCssSelector;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = require(\"./utils\");\nfunction renderEntity(entity) {\n    var res = '';\n    switch (entity.type) {\n        case 'ruleSet':\n            var currentEntity = entity.rule;\n            var parts = [];\n            while (currentEntity) {\n                if (currentEntity.nestingOperator) {\n                    parts.push(currentEntity.nestingOperator);\n                }\n                parts.push(renderEntity(currentEntity));\n                currentEntity = currentEntity.rule;\n            }\n            res = parts.join(' ');\n            break;\n        case 'selectors':\n            res = entity.selectors.map(renderEntity).join(', ');\n            break;\n        case 'rule':\n            if (entity.tagName) {\n                if (entity.tagName === '*') {\n                    res = '*';\n                }\n                else {\n                    res = utils_1.escapeIdentifier(entity.tagName);\n                }\n            }\n            if (entity.id) {\n                res += \"#\" + utils_1.escapeIdentifier(entity.id);\n            }\n            if (entity.classNames) {\n                res += entity.classNames.map(function (cn) {\n                    return \".\" + (utils_1.escapeIdentifier(cn));\n                }).join('');\n            }\n            if (entity.attrs) {\n                res += entity.attrs.map(function (attr) {\n                    if ('operator' in attr) {\n                        if (attr.valueType === 'substitute') {\n                            return \"[\" + utils_1.escapeIdentifier(attr.name) + attr.operator + \"$\" + attr.value + \"]\";\n                        }\n                        else {\n                            return \"[\" + utils_1.escapeIdentifier(attr.name) + attr.operator + utils_1.escapeStr(attr.value) + \"]\";\n                        }\n                    }\n                    else {\n                        return \"[\" + utils_1.escapeIdentifier(attr.name) + \"]\";\n                    }\n                }).join('');\n            }\n            if (entity.pseudos) {\n                res += entity.pseudos.map(function (pseudo) {\n                    if (pseudo.valueType) {\n                        if (pseudo.valueType === 'selector') {\n                            return \":\" + utils_1.escapeIdentifier(pseudo.name) + \"(\" + renderEntity(pseudo.value) + \")\";\n                        }\n                        else if (pseudo.valueType === 'substitute') {\n                            return \":\" + utils_1.escapeIdentifier(pseudo.name) + \"($\" + pseudo.value + \")\";\n                        }\n                        else if (pseudo.valueType === 'numeric') {\n                            return \":\" + utils_1.escapeIdentifier(pseudo.name) + \"(\" + pseudo.value + \")\";\n                        }\n                        else {\n                            return (\":\" + utils_1.escapeIdentifier(pseudo.name) +\n                                \"(\" + utils_1.escapeIdentifier(pseudo.value) + \")\");\n                        }\n                    }\n                    else {\n                        return \":\" + utils_1.escapeIdentifier(pseudo.name);\n                    }\n                }).join('');\n            }\n            break;\n        default:\n            throw Error('Unknown entity type: \"' + entity.type + '\".');\n    }\n    return res;\n}\nexports.renderEntity = renderEntity;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar parser_context_1 = require(\"./parser-context\");\nvar render_1 = require(\"./render\");\nvar CssSelectorParser = /** @class */ (function () {\n    function CssSelectorParser() {\n        this.pseudos = {};\n        this.attrEqualityMods = {};\n        this.ruleNestingOperators = {};\n        this.substitutesEnabled = false;\n    }\n    CssSelectorParser.prototype.registerSelectorPseudos = function () {\n        var pseudos = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            pseudos[_i] = arguments[_i];\n        }\n        for (var _a = 0, pseudos_1 = pseudos; _a < pseudos_1.length; _a++) {\n            var pseudo = pseudos_1[_a];\n            this.pseudos[pseudo] = 'selector';\n        }\n        return this;\n    };\n    CssSelectorParser.prototype.unregisterSelectorPseudos = function () {\n        var pseudos = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            pseudos[_i] = arguments[_i];\n        }\n        for (var _a = 0, pseudos_2 = pseudos; _a < pseudos_2.length; _a++) {\n            var pseudo = pseudos_2[_a];\n            delete this.pseudos[pseudo];\n        }\n        return this;\n    };\n    CssSelectorParser.prototype.registerNumericPseudos = function () {\n        var pseudos = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            pseudos[_i] = arguments[_i];\n        }\n        for (var _a = 0, pseudos_3 = pseudos; _a < pseudos_3.length; _a++) {\n            var pseudo = pseudos_3[_a];\n            this.pseudos[pseudo] = 'numeric';\n        }\n        return this;\n    };\n    CssSelectorParser.prototype.unregisterNumericPseudos = function () {\n        var pseudos = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            pseudos[_i] = arguments[_i];\n        }\n        for (var _a = 0, pseudos_4 = pseudos; _a < pseudos_4.length; _a++) {\n            var pseudo = pseudos_4[_a];\n            delete this.pseudos[pseudo];\n        }\n        return this;\n    };\n    CssSelectorParser.prototype.registerNestingOperators = function () {\n        var operators = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            operators[_i] = arguments[_i];\n        }\n        for (var _a = 0, operators_1 = operators; _a < operators_1.length; _a++) {\n            var operator = operators_1[_a];\n            this.ruleNestingOperators[operator] = true;\n        }\n        return this;\n    };\n    CssSelectorParser.prototype.unregisterNestingOperators = function () {\n        var operators = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            operators[_i] = arguments[_i];\n        }\n        for (var _a = 0, operators_2 = operators; _a < operators_2.length; _a++) {\n            var operator = operators_2[_a];\n            delete this.ruleNestingOperators[operator];\n        }\n        return this;\n    };\n    CssSelectorParser.prototype.registerAttrEqualityMods = function () {\n        var mods = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            mods[_i] = arguments[_i];\n        }\n        for (var _a = 0, mods_1 = mods; _a < mods_1.length; _a++) {\n            var mod = mods_1[_a];\n            this.attrEqualityMods[mod] = true;\n        }\n        return this;\n    };\n    CssSelectorParser.prototype.unregisterAttrEqualityMods = function () {\n        var mods = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            mods[_i] = arguments[_i];\n        }\n        for (var _a = 0, mods_2 = mods; _a < mods_2.length; _a++) {\n            var mod = mods_2[_a];\n            delete this.attrEqualityMods[mod];\n        }\n        return this;\n    };\n    CssSelectorParser.prototype.enableSubstitutes = function () {\n        this.substitutesEnabled = true;\n        return this;\n    };\n    CssSelectorParser.prototype.disableSubstitutes = function () {\n        this.substitutesEnabled = false;\n        return this;\n    };\n    CssSelectorParser.prototype.parse = function (str) {\n        return parser_context_1.parseCssSelector(str, 0, this.pseudos, this.attrEqualityMods, this.ruleNestingOperators, this.substitutesEnabled);\n    };\n    CssSelectorParser.prototype.render = function (path) {\n        return render_1.renderEntity(path).trim();\n    };\n    return CssSelectorParser;\n}());\nexports.CssSelectorParser = CssSelectorParser;\n", "/**\n * @typedef {import('./types.js').Selectors} Selectors\n * @typedef {import('./types.js').RuleSet} RuleSet\n */\n\nimport {CssSelectorParser} from 'css-selector-parser'\n\nconst parser = new CssSelectorParser()\n\nparser.registerAttrEqualityMods('~', '^', '$', '*')\nparser.registerSelectorPseudos('any', 'matches', 'not', 'has')\nparser.registerNestingOperators('>', '+', '~')\n\n/**\n * @param {string} selector\n * @returns {Selectors | RuleSet | null}\n */\nexport function parse(selector) {\n  if (typeof selector !== 'string') {\n    throw new TypeError('Expected `string` as selector, not `' + selector + '`')\n  }\n\n  return parser.parse(selector)\n}\n", "/**\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Node} Node\n * @typedef {import('./lib/types.js').SelectState} SelectState\n * @typedef {Record<string, unknown> & {type: string, position?: Position | undefined}} NodeLike\n */\n\nimport {queryToSelectors, walk} from './lib/walk.js'\nimport {parse} from './lib/parse.js'\nimport {parent} from './lib/util.js'\n\n/**\n * Check that the given `node` matches `selector`.\n *\n * This only checks the node itself, not the surrounding tree.\n * Thus, nesting in selectors is not supported (`paragraph strong`,\n * `paragraph > strong`), neither are selectors like `:first-child`, etc.\n * This only checks that the given node matches the selector.\n *\n * @param {string} selector\n *   CSS selector, such as (`heading`, `link, linkReference`).\n * @param {Node | NodeLike | null | undefined} [node]\n *   Node that might match `selector`.\n * @returns {boolean}\n *   Whether `node` matches `selector`.\n */\nexport function matches(selector, node) {\n  const state = createState(selector, node)\n  state.one = true\n  state.shallow = true\n  walk(state, node || undefined)\n  return state.results.length > 0\n}\n\n/**\n * Select the first node that matches `selector` in the given `tree`.\n *\n * Searches the tree in *preorder*.\n *\n * @param {string} selector\n *   CSS selector, such as (`heading`, `link, linkReference`).\n * @param {Node | NodeLike | null | undefined} [tree]\n *   Tree to search.\n * @returns {Node | null}\n *   First node in `tree` that matches `selector` or `null` if nothing is\n *   found.\n *\n *   This could be `tree` itself.\n */\nexport function select(selector, tree) {\n  const state = createState(selector, tree)\n  state.one = true\n  walk(state, tree || undefined)\n  // To do next major: return `undefined`.\n  return state.results[0] || null\n}\n\n/**\n * Select all nodes that match `selector` in the given `tree`.\n *\n * Searches the tree in *preorder*.\n *\n * @param {string} selector\n *   CSS selector, such as (`heading`, `link, linkReference`).\n * @param {Node | NodeLike | null | undefined} [tree]\n *   Tree to search.\n * @returns {Array<Node>}\n *   Nodes in `tree` that match `selector`.\n *\n *   This could include `tree` itself.\n */\nexport function selectAll(selector, tree) {\n  const state = createState(selector, tree)\n  walk(state, tree || undefined)\n  return state.results\n}\n\n/**\n * @param {string} selector\n *   Selector to parse.\n * @param {Node | null | undefined} tree\n *   Tree to search.\n * @returns {SelectState}\n */\nfunction createState(selector, tree) {\n  return {\n    // State of the query.\n    rootQuery: queryToSelectors(parse(selector)),\n    results: [],\n    scopeNodes: tree\n      ? parent(tree) &&\n        // Root in nlcst.\n        (tree.type === 'RootNode' || tree.type === 'root')\n        ? tree.children\n        : [tree]\n      : [],\n    one: false,\n    shallow: false,\n    found: false,\n    // State in the tree.\n    typeIndex: undefined,\n    nodeIndex: undefined,\n    typeCount: undefined,\n    nodeCount: undefined\n  }\n}\n"],
  "mappings": "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",
  "names": ["one", "boolbase", "parent", "handle", "nthCheck", "parent", "name", "nest", "parent", "empty", "count", "parse", "pseudo", "pseudo", "CssSelectorParser", "pseudo", "parse", "init_parse", "matches", "parse", "init_parse"]
}
