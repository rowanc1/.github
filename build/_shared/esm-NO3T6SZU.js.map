{
  "version": 3,
  "sources": ["../../../../../node_modules/myst-ext-card/dist/esm/index.js"],
  "sourcesContent": ["import { ParseTypesEnum } from 'myst-common';\nconst HEADER_REGEX = /((?<before>[\\s\\S]*?)\\s+){0,1}\\^\\^\\^(\\s+(?<after>[\\s\\S]*)){0,1}/;\nexport const cardDirective = {\n    name: 'card',\n    alias: 'grid-item-card',\n    arg: {\n        type: ParseTypesEnum.parsed,\n    },\n    options: {\n        link: {\n            type: ParseTypesEnum.string,\n        },\n        header: {\n            type: ParseTypesEnum.parsed,\n        },\n        footer: {\n            type: ParseTypesEnum.parsed,\n        },\n        // // https://sphinx-design.readthedocs.io/en/furo-theme/cards.html#card-options\n        // width\n        // margin\n        // padding\n        // 'text-align'\n        // 'img-top'\n        // 'img-background'\n        // 'img-bottom'\n        // link\n        // // This should be removed, it is picked up just as any other link that can also be a reference\n        // 'link-type'\n        // 'link-alt'\n        // // This should just be a class that is recognized (similar to dropdown)\n        // shadow\n        // 'class-card'\n        // // I feel like all of these should *not* be included.\n        // // Instead us a css selector on `class`: for example, `.card.my-class > header { customCss: prop; }`\n        // 'class-header'\n        // 'class-body'\n        // 'class-title'\n        // 'class-footer'\n        // 'class-img-top'\n        // 'class-img-bottom'\n        // // https://sphinx-design.readthedocs.io/en/furo-theme/grids.html#grid-item-card-options\n        // columns\n        // 'class-item' // This seems the same as `class-card`?\n    },\n    body: {\n        type: ParseTypesEnum.parsed,\n        required: true,\n    },\n    run(data) {\n        const { link, header, footer } = data.options || {};\n        let headerChildren;\n        let bodyChildren;\n        let footerChildren;\n        if (header || footer) {\n            headerChildren = header ? [{ type: 'paragraph', children: header }] : [];\n            bodyChildren = data.body;\n            footerChildren = footer ? [{ type: 'paragraph', children: footer }] : [];\n        }\n        else {\n            const [beforeHeaderDelim, afterHeaderDelim] = splitChildrenOnDelim(data.body);\n            headerChildren = afterHeaderDelim.length ? beforeHeaderDelim : [];\n            const nonHeaderChildren = afterHeaderDelim.length ? afterHeaderDelim : beforeHeaderDelim;\n            [bodyChildren, footerChildren] = splitChildrenOnBlockBreak(nonHeaderChildren);\n        }\n        const children = [];\n        if (headerChildren.length) {\n            children.push({\n                type: 'header',\n                children: headerChildren,\n            });\n        }\n        if (data.arg) {\n            children.push({\n                type: 'cardTitle',\n                children: data.arg,\n            });\n        }\n        children.push(...bodyChildren);\n        if (footerChildren.length) {\n            children.push({\n                type: 'footer',\n                children: footerChildren,\n            });\n        }\n        return [\n            {\n                type: 'card',\n                url: link,\n                children,\n            },\n        ];\n    },\n};\n/**\n * Splits paragraph node into two paragraph nodes based on delimiter string\n *\n * The delimiter must be in a text node that is a direct child of the paragraph\n */\nexport function splitParagraphNode(node) {\n    var _a;\n    const preChildren = [];\n    const postChildren = [];\n    let post = false;\n    (_a = node.children) === null || _a === void 0 ? void 0 : _a.forEach((child) => {\n        var _a;\n        if (post) {\n            postChildren.push(child);\n            return;\n        }\n        if (child.type !== 'text' || !child.value) {\n            preChildren.push(child);\n            return;\n        }\n        const value = child.value;\n        const match = HEADER_REGEX.exec(value);\n        if (!match) {\n            preChildren.push(child);\n            return;\n        }\n        post = true;\n        const { before, after } = (_a = match.groups) !== null && _a !== void 0 ? _a : {};\n        if (before) {\n            preChildren.push({ type: 'text', value: before });\n        }\n        if (after) {\n            postChildren.push({ type: 'text', value: after });\n        }\n    });\n    const output = {\n        before: preChildren.length ? Object.assign(Object.assign({}, node), { children: preChildren }) : null,\n        after: postChildren.length ? Object.assign(Object.assign({}, node), { children: postChildren }) : null,\n        post,\n    };\n    return output;\n}\nfunction splitChildrenOnDelim(children) {\n    const preChildren = [];\n    const postChildren = [];\n    let post = false;\n    children.forEach((child) => {\n        if (post) {\n            postChildren.push(child);\n        }\n        else if (child.type !== 'paragraph') {\n            preChildren.push(child);\n        }\n        else {\n            const split = splitParagraphNode(child);\n            const { before, after } = split;\n            post = split.post;\n            if (before) {\n                preChildren.push(before);\n            }\n            if (after) {\n                postChildren.push(after);\n            }\n        }\n    });\n    return [preChildren, postChildren];\n}\n/**\n * Splits list of nodes into two lists, before and after the first\n * instance of a given node type (this node is lost).\n */\nfunction splitChildrenOnBlockBreak(children) {\n    const preChildren = [];\n    const postChildren = [];\n    let post = false;\n    children.forEach((child) => {\n        if (post) {\n            postChildren.push(child);\n        }\n        else if (child.type !== 'blockBreak') {\n            preChildren.push(child);\n        }\n        else {\n            post = true;\n        }\n    });\n    return [preChildren, postChildren];\n}\n//   const cardTitleHastHandler: Handler = (h, node) => h(node, 'div'),\n//   const footerHastHandler: Handler = (h, node) => h(node, 'footer'),\n//   const headerHastHandler: Handler = (h, node) => h(node, 'header'),\n//   const cardHastHandler: Handler = (h, node) => h(node, 'details'),\n"],
  "mappings": "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",
  "names": ["_a"]
}
