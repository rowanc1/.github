{
  "version": 3,
  "sources": ["../../../../../node_modules/doi-utils/src/validatePart.ts", "../../../../../node_modules/doi-utils/src/resolvers.ts", "../../../../../node_modules/doi-utils/src/index.ts"],
  "sourcesContent": ["const DOI_VALIDATION_PATTERN = /^10.\\d{4,9}\\/[-._;()/:A-Z0-9]+$/i; // source: https://www.crossref.org/blog/dois-and-matching-regular-expressions/\n// const DOI_URL_PATTERN = /(?:https?:\\/\\/)?(?:dx\\.)?(?:www\\.)?doi.org\\//;\n\n/**\n * Validate that the input DOI string is valid.\n *\n * Uses DOI pattern described here: https://www.crossref.org/blog/dois-and-matching-regular-expressions/\n *\n * @param possibleDOI\n * @returns true if DOI is valid\n */\nexport function validatePart(possibleDOI?: string): boolean {\n  if (!possibleDOI) return false;\n  return possibleDOI.match(DOI_VALIDATION_PATTERN) !== null;\n}\n", "import { validatePart } from './validatePart';\n\ninterface Resolver {\n  test: (url: URL) => boolean;\n  parse: (url: URL) => string;\n}\n\nconst doiOrg: Resolver = {\n  test(url) {\n    return !!url.hostname.match(/(?:dx\\.)?(?:www\\.)?doi\\.org/);\n  },\n  parse(url) {\n    return url.pathname.replace(/^\\//, '');\n  },\n};\n\nconst elife: Resolver = {\n  test(url) {\n    return url.hostname.endsWith('elifesciences.org') && url.pathname.startsWith('/articles/');\n  },\n  parse(url) {\n    return `10.7554/eLife.${url.pathname.replace('/articles/', '')}`;\n  },\n};\n\nconst zenodo: Resolver = {\n  test(url) {\n    return (\n      url.hostname.endsWith('zenodo.org') &&\n      !!url.pathname.match(/^\\/(?:record|badge\\/latestdoi)\\//)\n    );\n  },\n  parse(url) {\n    return `10.5281/zenodo.${url.pathname.replace(/^\\/(?:record|badge\\/latestdoi)\\//, '')}`;\n  },\n};\n\nfunction clumpParts(url: URL) {\n  const parts = url.pathname.split('/').filter((p) => !!p);\n  return parts.slice(0, -1).map((a, i) => `${a}/${parts[i + 1]}`);\n}\n\nconst pathParts: Resolver = {\n  test(url) {\n    return !!clumpParts(url).find(validatePart);\n  },\n  parse(url) {\n    return clumpParts(url).find(validatePart);\n  },\n};\n\nconst idInQuery: Resolver = {\n  test(url) {\n    return validatePart(url.searchParams.get('id'));\n  },\n  parse(url) {\n    return url.searchParams.get('id');\n  },\n};\n\nexport const STRICT_RESOLVERS = [doiOrg];\nexport const DEFAULT_RESOLVERS = [doiOrg, pathParts, elife, zenodo, idInQuery];\n", "import { DEFAULT_RESOLVERS, STRICT_RESOLVERS } from './resolvers';\nimport { validatePart } from './validatePart';\n\nexport { DEFAULT_RESOLVERS, STRICT_RESOLVERS } from './resolvers';\n\nexport type Options = {\n  strict?: boolean;\n};\n\n/**\n * Validate that the input string is valid.\n *\n * Uses DOI pattern described here: https://www.crossref.org/blog/dois-and-matching-regular-expressions/\n *\n * @param possibleDOI\n * @returns true if DOI is valid\n */\nfunction validate(possibleDOI?: string, opts?: Options): boolean {\n  if (!possibleDOI) return false;\n  return !!normalize(possibleDOI, opts);\n}\n\n/**\n * Normalize an input string to the component of the DOI\n *\n * @param possibleDOI\n * @returns a string if it is valid\n */\nfunction normalize(possibleDOI: string, opts?: Options): string | undefined {\n  let doi: string | undefined = undefined;\n  if (!possibleDOI) return undefined;\n  if (validatePart(possibleDOI)) return possibleDOI;\n  if (possibleDOI.startsWith('doi:')) {\n    doi = possibleDOI.slice(4);\n    if (validatePart(doi)) return doi;\n  }\n  try {\n    const url = new URL(possibleDOI.startsWith('http') ? possibleDOI : `http://${possibleDOI}`);\n    const resolvers = opts?.strict ? STRICT_RESOLVERS : DEFAULT_RESOLVERS;\n    const resolver = resolvers.find((r) => r.test(url));\n    if (!resolver) return undefined;\n    doi = resolver.parse(url);\n  } catch (error) {\n    // pass\n  }\n  if (validatePart(doi)) return doi;\n  return undefined;\n}\n\n/**\n * Builds a canonical URL pointing to https://doi.org\n *\n * @param possibleDOI\n * @returns the doi as a string\n */\nfunction buildUrl(possibleDOI: string, opts?: Options): string | undefined {\n  const doi = normalize(possibleDOI, opts);\n  if (!doi) return undefined;\n  return `https://doi.org/${doi}`;\n}\n\nexport default {\n  validatePart,\n  validate,\n  normalize,\n  buildUrl,\n};\n"],
  "mappings": ";AAAA,IAAMA,yBAAsB;AAWrB,SAASC,aAAaC,aAA+B;AAC1D,MAAI,CAACA;AAAa,WAAO;AACzB,SAAOA,YAAYC,MAAMH,sBAAsB,MAAM;;;;ACNvD,IAAMI,SAAmB;EACvBC,KAAKC,KAAK;AACR,WAAO,CAAC,CAACA,IAAIC,SAASC,MAAK,6BAAA;;EAE7BC,MAAMH,KAAK;AACT,WAAOA,IAAII,SAASC,QAAO,OAAQ,EAAE;;;AAIzC,IAAMC,QAAkB;EACtBP,KAAKC,KAAK;AACR,WAAOA,IAAIC,SAASM,SAAS,mBAAmB,KAAKP,IAAII,SAASI,WAAW,YAAY;;EAE3FL,MAAMH,KAAK;AACT,WAAO,iBAAiBA,IAAII,SAASC,QAAQ,cAAc,EAAE;;;AAIjE,IAAMI,SAAmB;EACvBV,KAAKC,KAAK;AACR,WACEA,IAAIC,SAASM,SAAS,YAAY,KAClC,CAAC,CAACP,IAAII,SAASF,MAAK,kCAAA;;EAGxBC,MAAMH,KAAK;AACT,WAAO,kBAAkBA,IAAII,SAASC,QAAO,oCAAqC,EAAE;;;AAIxF,SAASK,WAAWV,KAAU;AAC5B,QAAMW,QAAQX,IAAII,SAASQ,MAAM,GAAG,EAAEC;IAAO,CAACC,MAAM,CAAC,CAACA;EAAC;AACvD,SAAOH,MAAMI,MAAM,GAAG,EAAE,EAAEC;IAAI,CAACC,GAAGC,MAAM,GAAGD,KAAKN,MAAMO,IAAI;EAAI;;AAGhE,IAAMC,YAAsB;EAC1BpB,KAAKC,KAAK;AACR,WAAO,CAAC,CAACU,WAAWV,GAAG,EAAEoB,KAAKC,YAAY;;EAE5ClB,MAAMH,KAAK;AACT,WAAOU,WAAWV,GAAG,EAAEoB,KAAKC,YAAY;;;AAI5C,IAAMC,YAAsB;EAC1BvB,KAAKC,KAAK;AACR,WAAOqB,aAAarB,IAAIuB,aAAaC,IAAI,IAAI,CAAC;;EAEhDrB,MAAMH,KAAK;AACT,WAAOA,IAAIuB,aAAaC,IAAI,IAAI;;;AAI7B,IAAMC,mBAAmB;EAAC3B;;AAC1B,IAAM4B,oBAAoB;EAAC5B;EAAQqB;EAAWb;EAAOG;EAAQa;;;;AC5CpE,SAASK,SAASC,aAAsBC,MAAyB;AAC/D,MAAI,CAACD;AAAa,WAAO;AACzB,SAAO,CAAC,CAACE,UAAUF,aAAaC,IAAI;;AAStC,SAASC,UAAUF,aAAqBC,MAAoC;AAC1E,MAAIE,MAA0BC;AAC9B,MAAI,CAACJ;AAAa,WAAOI;AACzB,MAAIC,aAAaL,WAAW;AAAG,WAAOA;AACtC,MAAIA,YAAYM,WAAW,MAAM,GAAG;AAClCH,UAAMH,YAAYO,MAAM,CAAC;AACzB,QAAIF,aAAaF,GAAG;AAAG,aAAOA;;AAEhC,MAAI;AACF,UAAMK,MAAM,IAAIC,IAAIT,YAAYM,WAAW,MAAM,IAAIN,cAAc,UAAUA,aAAa;AAC1F,UAAMU,aAAYT,SAAI,QAAJA,SAAI,SAAJA,SAAAA,KAAMU,UAASC,mBAAmBC;AACpD,UAAMC,WAAWJ,UAAUK;MAAK,CAACC,MAAMA,EAAEC,KAAKT,GAAG;IAAC;AAClD,QAAI,CAACM;AAAU,aAAOV;AACtBD,UAAMW,SAASI,MAAMV,GAAG;WACjBW,OAAP;;AAGF,MAAId,aAAaF,GAAG;AAAG,WAAOA;AAC9B,SAAOC;;AAST,SAASgB,SAASpB,aAAqBC,MAAoC;AACzE,QAAME,MAAMD,UAAUF,aAAaC,IAAI;AACvC,MAAI,CAACE;AAAK,WAAOC;AACjB,SAAO,mBAAmBD;;AAG5B,IAAA,cAAe;EACbE;EACAN;EACAG;EACAkB;;",
  "names": ["DOI_VALIDATION_PATTERN", "validatePart", "possibleDOI", "match", "doiOrg", "test", "url", "hostname", "match", "parse", "pathname", "replace", "elife", "endsWith", "startsWith", "zenodo", "clumpParts", "parts", "split", "filter", "p", "slice", "map", "a", "i", "pathParts", "find", "validatePart", "idInQuery", "searchParams", "get", "STRICT_RESOLVERS", "DEFAULT_RESOLVERS", "validate", "possibleDOI", "opts", "normalize", "doi", "undefined", "validatePart", "startsWith", "slice", "url", "URL", "resolvers", "strict", "STRICT_RESOLVERS", "DEFAULT_RESOLVERS", "resolver", "find", "r", "test", "parse", "error", "buildUrl"]
}
