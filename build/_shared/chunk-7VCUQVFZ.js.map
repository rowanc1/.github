{
  "version": 3,
  "sources": ["../../../../../node_modules/unist-util-map/lib/index.js", "../../../../../node_modules/nanoid/index.browser.js", "../../../../../node_modules/myst-common/dist/esm/utils.js", "../../../../../node_modules/myst-common/dist/esm/types.js"],
  "sourcesContent": ["/**\n * @typedef {import('unist').Node} Node\n */\n\n/**\n * @template {Node} [Kind=Node]\n *   Node type.\n * @typedef {import('./complex-types.js').MapFunction<Kind>} MapFunction\n *   Function called with a node, its index, and its parent to produce a new\n *   node.\n */\n\n/**\n * Create a new tree by mapping all nodes with the given function.\n *\n * @template {Node} Kind\n *   Type of input tree.\n * @param {Kind} tree\n *   Tree to map.\n * @param {MapFunction<Kind>} mapFunction\n *   Function called with a node, its index, and its parent to produce a new\n *   node.\n * @returns {Kind}\n *   New mapped tree.\n */\nexport function map(tree, mapFunction) {\n  // @ts-expect-error Looks like a children.\n  return preorder(tree, null, null)\n\n  /** @type {import('./complex-types.js').MapFunction<Kind>} */\n  function preorder(node, index, parent) {\n    const newNode = Object.assign({}, mapFunction(node, index, parent))\n\n    if ('children' in node) {\n      // @ts-expect-error Looks like a parent.\n      newNode.children = node.children.map(function (\n        /** @type {import('./complex-types.js').InclusiveDescendant<Kind>} */ child,\n        /** @type {number} */ index\n      ) {\n        return preorder(child, index, node)\n      })\n    }\n\n    return newNode\n  }\n}\n", "export { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nexport let nanoid = (size = 21) =>\n  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {\n    byte &= 63\n    if (byte < 36) {\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte > 62) {\n      id += '-'\n    } else {\n      id += '_'\n    }\n    return id\n  }, '')\n", "var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { map } from 'unist-util-map';\nimport { customAlphabet } from 'nanoid';\nfunction addMessageInfo(message, info) {\n    if (info === null || info === void 0 ? void 0 : info.note)\n        message.note = info === null || info === void 0 ? void 0 : info.note;\n    if (info === null || info === void 0 ? void 0 : info.url)\n        message.url = info === null || info === void 0 ? void 0 : info.url;\n    if (info === null || info === void 0 ? void 0 : info.fatal)\n        message.fatal = true;\n    return message;\n}\nexport function fileError(file, message, opts) {\n    return addMessageInfo(file.message(message, opts === null || opts === void 0 ? void 0 : opts.node, opts === null || opts === void 0 ? void 0 : opts.source), __assign(__assign({}, opts), { fatal: true }));\n}\nexport function fileWarn(file, message, opts) {\n    return addMessageInfo(file.message(message, opts === null || opts === void 0 ? void 0 : opts.node, opts === null || opts === void 0 ? void 0 : opts.source), opts);\n}\nexport function fileInfo(file, message, opts) {\n    return addMessageInfo(file.info(message, opts === null || opts === void 0 ? void 0 : opts.node, opts === null || opts === void 0 ? void 0 : opts.source), opts);\n}\nvar az = 'abcdefghijklmnopqrstuvwxyz';\nvar alpha = az + az.toUpperCase();\nvar numbers = '0123456789';\nvar nanoidAZ = customAlphabet(alpha, 1);\nvar nanoidAZ9 = customAlphabet(alpha + numbers, 9);\nexport function createId() {\n    return nanoidAZ() + nanoidAZ9();\n}\n/**\n * https://github.com/syntax-tree/mdast#association\n * @param label A label field can be present.\n *        label is a string value: it works just like title on a link or a\n *        lang on code: character escapes and character references are parsed.\n * @returns { identifier, label }\n */\nexport function normalizeLabel(label) {\n    if (!label)\n        return undefined;\n    var identifier = label\n        .replace(/[\\t\\n\\r ]+/g, ' ')\n        .trim()\n        .toLowerCase();\n    var html_id = createHtmlId(identifier);\n    return { identifier: identifier, label: label, html_id: html_id };\n}\nexport function createHtmlId(identifier) {\n    if (!identifier)\n        return undefined;\n    return identifier\n        .toLowerCase()\n        .replace(/[^a-z0-9-]/g, '-') // Remove any fancy characters\n        .replace(/^([0-9-])/, 'id-$1') // Ensure that the id starts with a letter\n        .replace(/-[-]+/g, '-') // Replace repeated `-`s\n        .replace(/(?:^[-]+)|(?:[-]+$)/g, ''); // Remove repeated `-`s at the start or the end\n}\nexport function liftChildren(tree, nodeType) {\n    map(tree, function (node) {\n        var _a, _b;\n        var children = (_b = (_a = node.children) === null || _a === void 0 ? void 0 : _a.map(function (child) {\n            if (child.type === nodeType && child.children)\n                return child.children;\n            return child;\n        })) === null || _b === void 0 ? void 0 : _b.flat();\n        // There are some checks in unist that look like `'children' in node`\n        // all children must be deleted, and not a key on the object\n        if (node && node.children == null)\n            delete node.children;\n        if (children !== undefined)\n            node.children = children;\n        return node;\n    });\n}\nexport function setTextAsChild(node, text) {\n    node.children = [{ type: 'text', value: text }];\n}\nexport function toText(content) {\n    if (!content)\n        return '';\n    if (!Array.isArray(content))\n        return toText([content]);\n    return content\n        .map(function (n) {\n        if (!n || typeof n === 'string')\n            return n || '';\n        if ('value' in n)\n            return n.value;\n        if ('children' in n && n.children)\n            return toText(n.children);\n        return '';\n    })\n        .join('');\n}\nexport function copyNode(node) {\n    return JSON.parse(JSON.stringify(node));\n}\nexport function mergeTextNodes(node) {\n    var _a;\n    var children = (_a = node.children) === null || _a === void 0 ? void 0 : _a.reduce(function (c, n) {\n        var _a;\n        if ((n === null || n === void 0 ? void 0 : n.type) !== 'text') {\n            c.push(mergeTextNodes(n));\n            return c;\n        }\n        var last = c[c.length - 1];\n        if ((last === null || last === void 0 ? void 0 : last.type) !== 'text') {\n            c.push(n);\n            return c;\n        }\n        if ((_a = n.position) === null || _a === void 0 ? void 0 : _a.end) {\n            if (!last.position)\n                last.position = {};\n            last.position.end = n.position.end;\n        }\n        if (!last.value)\n            last.value = '';\n        if (n.value)\n            last.value += n.value;\n        return c;\n    }, []);\n    if (children)\n        node.children = children;\n    return node;\n}\n", "export var SourceFileKind;\n(function (SourceFileKind) {\n    SourceFileKind[\"Article\"] = \"Article\";\n    SourceFileKind[\"Notebook\"] = \"Notebook\";\n})(SourceFileKind || (SourceFileKind = {}));\n// Types for defining roles and directives\nexport var ParseTypesEnum;\n(function (ParseTypesEnum) {\n    ParseTypesEnum[\"string\"] = \"string\";\n    ParseTypesEnum[\"number\"] = \"number\";\n    ParseTypesEnum[\"boolean\"] = \"boolean\";\n    ParseTypesEnum[\"parsed\"] = \"parsed\";\n})(ParseTypesEnum || (ParseTypesEnum = {}));\n"],
  "mappings": "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",
  "names": ["index", "SourceFileKind", "ParseTypesEnum"]
}
